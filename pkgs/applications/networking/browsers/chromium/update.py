#!/usr/bin/env python3
import os.path
import sys
import re
import inspect
import urllib.request
import bz2
import subprocess

HISTORY_URL = 'http://omahaproxy.appspot.com/history'
DOWNLOAD_URL = 'http://commondatastorage.googleapis.com/' \
               'chromium-browser-official/chromium-{}.tar.xz'

DEB_REPO_URL = 'https://dl.google.com/linux/chrome/deb/'
DEB_PACKAGES_URL = DEB_REPO_URL + 'dists/stable/main/binary-{}/Packages.bz2'

CHANNELS = ('dev', 'beta', 'stable')
ARCHS = ('amd64', 'i386')


def get_output(cmd):
    try:
        output = subprocess.check_output(cmd)
    except subprocess.CalledProcessError as e:
        return None

    return output.decode('utf-8')


def nix_prefetch_url(url):
    return get_output(['nix-prefetch-url', url]).strip()


def get_nix_attr(path, attr):
    out = get_output([
        'nix-instantiate', '--eval-only', '-A', attr, path
    ]).strip()

    if len(out) < 2 or out[0] != '"' or out[-1] != '"':
        msg = 'Cannot find Nix attribute "{}" (parsing failure?)'
        raise Exception(msg.format(attr))

    # Strip quotes
    return out[1:-1]


def get_chan_attr(src_path, chan, attr):
    return get_nix_attr(src_path, '{}.{}'.format(chan, attr))


def generate_sha256_cache(src_path):
    """Return a map of URL->sha256, based on the existing sources.nix"""
    cache = {}

    for chan in CHANNELS:
        url = get_chan_attr(src_path, chan, 'url')
        sha256 = get_chan_attr(src_path, chan, 'sha256')

        cache[url] = sha256

    return cache


def write_file(src_path, sources):
    f = open(src_path, 'w', encoding='utf-8')
    f.write(sources)
    f.close()


def get_url_binary(url):
    f = urllib.request.urlopen(url)
    data = f.read()
    f.close()

    return data


def get_url_text(url):
    return get_url_binary(url).decode('utf-8')


def get_deb_packages(arch):
    url = DEB_PACKAGES_URL.format(arch)
    packages_bz2 = get_url_binary(url)
    packages = bz2.decompress(packages_bz2)

    return packages.decode('utf-8')


class ChromiumUpdater:
    def __init__(self):
        pysrc_path = inspect.getsourcefile(sys.modules[__name__])
        self.src_path = os.path.join(os.path.dirname(pysrc_path),
                                     'sources.nix')

        self.history = get_url_text(HISTORY_URL)
        self.cache = generate_sha256_cache(self.src_path)
        self.deb_packages = {}

        for arch in ARCHS:
            self.deb_packages[arch] = get_deb_packages(arch)

    def do_update(self):
        sources = self.generate_sources_nix()
        write_file(self.src_path, sources)

    def generate_sources_nix(self):
        src = '# This file is autogenerated from update.py' \
              ' in the same directory.\n'
        src += '{\n'

        for chan in CHANNELS:
            src += self.generate_chan_expr(chan)

        src += '}\n'
        return src

    def generate_chan_expr(self, chan):
        print()
        print('Generating attributes for channel "{}"...'.format(chan))

        attrs = self.generate_chan_attrs(chan)

        print('Success!')

        src = '  {} = {{\n'.format(chan)
        src += '    version = "{}";\n'.format(attrs['version'])
        src += '    url = "{}";\n'.format(attrs['url'])
        src += '    sha256 = "{}";\n'.format(attrs['sha256'])

        for arch in ARCHS:
            src += '\n'
            src += '    deb_{} = {{\n'.format(arch)
            src += '      url = "{}";\n'.format(attrs['deb'][arch]['url'])
            src += '      sha1 = "{}";\n'.format(attrs['deb'][arch]['sha1'])
            src += '    };\n'

        src += '  };\n'

        return src

    def generate_chan_attrs(self, chan):
        """Generate the attributes for a channel"""

        new_version = self.get_new_version(chan, 0)

        print('Trying latest version: {}'.format(new_version))

        attrs = self.generate_attrs_for(chan, new_version)
        if attrs is not None:
            return attrs

        # We couldn't retrieve latest version, let's go back one version
        new_version = self.get_new_version(chan, 1)

        msg = "Failed to fetch latest version... trying previous version: {}"
        print(msg.format(new_version))

        attrs = self.generate_attrs_for(chan, new_version)
        if attrs is None:
            msg = 'Failure downloading files for channel `{}`'.format(chan)
            raise Exception(msg)

        return attrs

    def get_new_version(self, chan, index):
        """
        Scan version history and return the `index`-th latest version available
        for channel `chan`.
        """

        regex = r'^linux,{},(\d.*?),'.format(chan)
        m = re.findall(regex, self.history, re.MULTILINE)
        if len(m) == 0:
            msg = 'Could not find any versions for channel `{}` in history URL'
            raise Exception(msg.format(chan))

        if len(m) < (index + 1):
            msg = 'Only found latest {} version(s) for channel `{}` in ' \
                  'history URL, needed {}'
            raise Exception(msg.format(len(m) + 1, chan, index + 1))

        return m[index]

    def generate_attrs_for(self, chan, version):
        attrs = {}

        attrs['version'] = version
        attrs['url'] = DOWNLOAD_URL.format(version)

        # Fetch DEB package info before downloading sources, otherwise
        # (in case of failure) we may end up wasting bandwidth

        attrs['deb'] = {}

        for arch in ARCHS:
            deb_attrs = {}
            deb_version, url, sha1 = self.get_deb_pkginfo(chan, arch)
            if deb_version != version:
                msg = 'Warning: wanted version "{}" but only found DEB ' \
                      'package for version "{}"'
                print(msg.format(version, deb_version))
                return None

            deb_attrs['url'] = url
            deb_attrs['sha1'] = sha1

            attrs['deb'][arch] = deb_attrs

        sha256 = self.get_sha256(attrs['url'])
        if sha256 is None:
            return None

        attrs['sha256'] = sha256
        return attrs

    def get_sha256(self, url):
        """
        Get the SHA256 for the URL, reusing SHA256 hashes from cache if
        possible.
        """
        print('Calculating SHA256 hash for URL: {}'.format(url))
        if url in self.cache:
            sha256 = self.cache[url]
            print('Found cached SHA256 hash: {}'.format(sha256))
            return self.cache[url]

        print('Not found in cache, downloading...')

        sha256 = nix_prefetch_url(url)
        if sha256 is not None:
            # Add new SHA256 hash to cache
            self.cache[url] = sha256

        return sha256

    def get_deb_pkginfo(self, chan, arch):
        """
        Parse the Debian repository's `Release` file and return package URL +
        SHA1.
        """
        if chan == 'dev':
            deb_chan = 'unstable'
        else:
            deb_chan = chan

        regex = r'^Package: google-chrome-{}$'.format(deb_chan)
        regex += r'.*?'
        # Ignore '-1' version suffix
        regex += r'^Version: (\d[\d.]*?)(?:-.*?)$'
        regex += r'.*?'
        regex += r'^Filename: (.*?)$'
        regex += r'.*?'
        regex += r'^SHA1: (.*?)$'

        m = re.search(regex, self.deb_packages[arch], re.MULTILINE | re.DOTALL)
        if m is None:
            raise Exception('Error parsing debian `Packages` file: '
                            'couldn\'t find requested package')

        assert len(m.groups()) == 3

        version = m.group(1)
        url = DEB_REPO_URL + m.group(2)
        sha1 = m.group(3)

        return version, url, sha1


if __name__ == '__main__':
    updater = ChromiumUpdater()
    updater.do_update()

#!/usr/bin/env python3

import sys, inspect, os.path, urllib.request, re, bz2, subprocess

HISTORY_URL = 'http://omahaproxy.appspot.com/history'
DOWNLOAD_URL = 'http://commondatastorage.googleapis.com/chromium-browser-official/chromium-{}.tar.xz'

DEB_REPO_URL = 'https://dl.google.com/linux/chrome/deb/'
DEB_PACKAGES_URL = DEB_REPO_URL + 'dists/stable/main/binary-{}/Packages.bz2'

CHANNELS = ('dev', 'beta', 'stable')
ARCHS = ('amd64', 'i386')

def get_output(cmd):
	try:
		output = subprocess.check_output(cmd)
	except subprocess.CalledProcessError as e:
		return None

	return output.decode('utf-8')

def nix_prefetch_url(url):
	return get_output(['nix-prefetch-url', url]).strip()

def get_nix_attr(path, attr):
	out = get_output(['nix-instantiate', '--eval-only', '-A', attr, path]).strip()

	if len(out) < 2 or out[0] != '"' or out[-1] != '"':
		raise Exception('Cannot find Nix attribute "{}" (parsing failure?)'.format(attr))

	# Strip quotes
	return out[1:-1]

def get_chan_attr(src_path, chan, attr):
	return get_nix_attr(src_path, '{}.{}'.format(chan, attr))

def generate_sha256_cache(src_path):
	"""Return a map of URL->sha256, based on the existing sources.nix"""
	cache = {}

	for chan in CHANNELS:
		url = get_chan_attr(src_path, chan, 'url')
		sha256 = get_chan_attr(src_path, chan, 'sha256')

		cache[url] = sha256

	return cache

def write_file(src_path, sources):
	f = open(src_path, 'w', encoding = 'utf-8')
	f.write(sources)
	f.close()

def get_url_binary(url):
	f = urllib.request.urlopen(url)
	data = f.read()
	f.close()

	return data

def get_url_text(url):
	return get_url_binary(url).decode('utf-8')

def get_deb_packages(arch):
	url = DEB_PACKAGES_URL.format(arch)
	packages_bz2 = get_url_binary(url)
	packages = bz2.decompress(packages_bz2)

	return packages.decode('utf-8')

class ChromiumUpdater:
	def __init__(self):
		pysrc_path = inspect.getsourcefile(sys.modules[__name__])
		self.src_path = os.path.join(os.path.dirname(pysrc_path), 'sources.nix')

		self.history = get_url_text(HISTORY_URL)
		self.cache = generate_sha256_cache(self.src_path)
		self.deb_packages = {}

		for arch in ARCHS:
			self.deb_packages[arch] = get_deb_packages(arch)

	def do_update(self):
		sources = self.generate_sources_nix()
		write_file(self.src_path, sources)

	def generate_sources_nix(self):
		src = '# This file is autogenerated from update.py in the same directory.\n'
		src += '{\n'

		for chan in CHANNELS:
			src += self.generate_chan_expr(chan)

		src += '}\n'
		return src

	def generate_chan_expr(self, chan):
		print()
		print('Generating attributes for channel "{}"...'.format(chan))

		attrs = self.generate_chan_attrs(chan)

		print('Success!')

		src =  '  {} = {{\n'.format(chan)
		src += '    version = "{}";\n'.format(attrs['version'])
		src += '    url = "{}";\n'.format(attrs['url'])
		src += '    sha256 = "{}";\n'.format(attrs['sha256'])

		for arch in ARCHS:
			src += '\n'
			src += '    deb_{} = {{\n'.format(arch)
			src += '      url = "{}";\n'.format(attrs['deb'][arch]['url'])
			src += '      sha1 = "{}";\n'.format(attrs['deb'][arch]['sha1'])
			src += '    };\n'

		src += '  };\n'

		return src

	def generate_chan_attrs(self, chan):
		"""Generate the attributes for a channel"""

		new_version = self.get_new_version(chan, 0)

		print('Trying latest version: {}'.format(new_version))

		attrs = self.generate_attrs_for(chan, new_version)
		if attrs != None:
			return attrs

		# We couldn't retrieve latest version, let's go back one version
		new_version = self.get_new_version(chan, 1)

		print('Failed to fetch latest version... trying previous version: {}'.format(new_version))

		attrs = self.generate_attrs_for(chan, new_version)
		if attrs == None:
			raise Exception('Failure downloading files for channel `{}`'.format(chan))

		return attrs

	def get_new_version(self, chan, index):
		"""Scan version history and return the `index`-th latest version available for channel `chan`"""

		regex = r'^linux,{},(\d.*?),'.format(chan)
		m = re.findall(regex, self.history, re.MULTILINE)
		if len(m) == 0:
			msg = 'Could not find any versions for channel `{}` in history URL'.format(chan)
			raise Exception(msg)

		if len(m) < (index + 1):
			msg = 'Only found latest {} version(s) for channel `{}` in history URL, needed {}'.format(len(m) + 1, chan, index + 1)
			raise Exception(msg)

		return m[index]

	def generate_attrs_for(self, chan, version):
		attrs = {}

		attrs['version'] = version
		attrs['url'] = DOWNLOAD_URL.format(version)

		# Fetch DEB package info before downloading sources, otherwise
		# (in case of failure) we may end up wasting bandwidth

		attrs['deb'] = {}

		for arch in ARCHS:
			deb_attrs = {}
			deb_version, url, sha1 = self.get_deb_pkginfo(chan, arch)
			if deb_version != version:
				print('Warning: wanted version "{}" but only found DEB package for version "{}"'.format(version, deb_version))
				return None

			deb_attrs['url'] = url
			deb_attrs['sha1'] = sha1

			attrs['deb'][arch] = deb_attrs

		sha256 = self.get_sha256(attrs['url'])
		if sha256 == None:
			return None

		attrs['sha256'] = sha256
		return attrs

	def get_sha256(self, url):
		"""Get the SHA256 for the URL, reusing SHA256 hashes from cache if possible"""
		print('Calculating SHA256 hash for URL: {}'.format(url))
		if url in self.cache:
			sha256 = self.cache[url]
			print('Found cached SHA256 hash: {}'.format(sha256))
			return self.cache[url]

		print('Not found in cache, downloading...')

		sha256 = nix_prefetch_url(url)
		if sha256 != None:
			# Add new SHA256 hash to cache
			self.cache[url] = sha256

		return sha256

	def get_deb_pkginfo(self, chan, arch):
		"""Parse the Debian repository's `Release` file and return package URL + SHA1"""
		if chan == 'dev':
			deb_chan = 'unstable'
		else:
			deb_chan = chan

		regex = r'^Package: google-chrome-{}$'.format(deb_chan)
		regex += r'.*?'
		regex += r'^Version: (\d[\d.]*?)(?:-.*?)$' # Ignore '-1' version suffix
		regex += r'.*?'
		regex += r'^Filename: (.*?)$'
		regex += r'.*?'
		regex += r'^SHA1: (.*?)$'

		m = re.search(regex, self.deb_packages[arch], re.MULTILINE | re.DOTALL)
		if m == None:
			raise Exception('Error parsing debian `Packages` file: couldn\'t find requested package')

		assert len(m.groups()) == 3

		version = m.group(1)
		url = DEB_REPO_URL + m.group(2)
		sha1 = m.group(3)

		return version, url, sha1

if __name__ == '__main__':
	updater = ChromiumUpdater()
	updater.do_update()
